## JavaScript笔记

#### JavaScript基础

* JS简介
  * 解释型语言、动态脚本语言、面向对象
  * 主要包括三个部分：ECMAScript、DOM和BOM

* 编写位置：

  * 引入外部文件：script标签一旦引入外部文件，就不能在编写代码了，即使编写了浏览器也会自动忽略；如果需要则需要再次创建一个script标签

* 基本语法：

  * JS严格区分大小写
  * JS中每条语句以分号结尾(;)
  * js中自动忽略空格和换行

* 字面量和变量

  * 字面量——常量，不可变的值，可以直接使用
  * 变量——用来保存字面量，变量的值可以任意改变，通过变量对字面量进行描述，用var声明变量

* 常量——不可变的变量

* 标识符

* 数据类型：字面量类型

  **六种数据类型**：

  * 基本数据类型：String 字符串、Number 数值、Boolean 布尔值、Null 空值——专门用来表示一个空对象、Undefined 未定义
  * 引用数据类型：Object 对象
  * 强制类型转换——String
    * 调用被转换数据类型的**toString()**方法，此方法返回一个新的字符串；null和undefined没有toString()方法
    * 调用**String()**方法并将要转化的数据类型作为参数，返回一个新的字符串，可以将null和undefined用此方法转为字符串
    * 可以通过+“” 的方式将任意类型转换成String类型
  * 强制类型转换——Number
    * 使用Number()函数
    * parseInt() 把一个字符串装换成一个整数，对于非String，先转换成成String然后转换成数字
    * parseFloat() 把一个字符串装换成一个整数
  * 其它进制的数字——0x：16进制；0：八进制；0b：二进制
  * 强制类型装换——Boolean
    * 调用Boolean()函数将不同数据类型转换成Boolean类型
    * 对象会转换成True
    * 隐式类型转换：为任意数据类型做两次非运算，即可将其转换为Boolean值
  * typeof返回值——number、string、boolean、undefined、object

* 字符串

* 一元运算符

  * 一元运算符，只需要一个操作数
    * 正号+，不会对数字产生影响
    * 负号-，可以对数字进行取反操作
  * 对于非Number类型的值
    * 将值先转换为Number，然后进行运算
    * 可以对其他的数据类型使用+，来将其转换为Number，原理与Number()函数一样

* 逻辑运算符

  * 非布尔值的情况
    * 对于非布尔值进行与或运算时，会将其转换为布尔值，然后进行运算，并且返回原值
    * 与运算
      * 如果第一个值为true，则必然返回第二个值
      * 如果第一个值为false，则直接返回第一个值
      * **遇到false则返回对应的值**
    * 或运算
      * 如果第一个值为true，则直接返回第一个值
      * 如果第一个值为false，则直接返回第二个值
      * **遇到true返回对应的值**
  
* 赋值运算符
  
* 关系运算符
  
  * 非数值比较的情况
    * 任何值和NaN做任何比较都是false
    * 两个字符串比较时，比较两者的Unicode编码
  * 相等运算符
    * 相等运算符用来比较两个值是否相等，相等会返回true，否则会返回false
    * 使用==来做相等运算
      * 使用==来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后进行比较
    * 使用===来做全等运算，不会将两边的值进行类型转换
  
* 条件运算符
  
  * 三元运算符
  * 运算符的优先级：[JavaScript 算数 (w3school.com.cn)](https://www.w3school.com.cn/js/js_arithmetic.asp)
  
* 条件分支语句
  
  * switch...case...语句
  
    在执行语句时会依此将case后的表达式的值和switch后的条件表达式的值进行**全等比较**
  
    如果比较结果为true，则从当前case处开始执行代码，当前case后的所有代码都会执行，可以在case后添加break；如果比较结果为false，则会继续向下比较

#### 对象

* object——引用数据类型

* 对象的分类：

  * 内建对象：由ES标准中定义的对象，在任何的ES的实现中都可以使用

    比如：Math、String、Number、Boolean、Function、Object...

  * 宿主对象：由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象

    比如：BOM DOM

  * 自定义对象：由开发人员自己创建的对象

    * 使用new关键字调用的函数，是构造函数constructor——构造函数是专门用来创建对象的函数

    * in 运算符——通过该运算符可以检查一个对象中是否含有指定的属性

      如果有则返回true；如果没有则返回false——"属性名" in 对象

* 基本数据类型和引用数据类型

  * JS中的变量都是保存在**栈内存**中的，基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改其中一个不会对其他的造成影响
  
  * 对象是保存在**堆内存**中的，每创建一个对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用）
  
  * 对象字面量——创建对象；var obj = {} 本质上与new相同
  
  * 枚举对象中的属性：for...in...
  
  * 可变类型：对象属于可变类型
  
    原始值都属于不可变类型，一旦创建就无法修改，在内存中原始值是唯一的

#### 函数

* 函数也是一个对象，函数可以封装一些功能（代码），在需要时可以执行这些功能

* 函数的创建方式
  * 函数声明   function 函数名([形参1、形参2...]){}
  * 函数表达式 const 函数名 = function([形参1、形参2...]){}
  * 箭头函数 () => {} ——最常用
  
* 参数

  * 形式参数

    * 在定义函数时，可以在函数中指定数量不等的形式参数（形参）
    * **在函数中定义形参，就相当于在函数内部声明了对应的变量但没有赋值**

  * 实际参数

    * 在调用函数时，可以在函数的()传递数量不等的实参
    * 实参会赋值给其对应的形参
    * 如果实参多余形参，则多余的实参不会使用
    * 如果形参多余实参，则多余的形参为undefined

  * 对象作为参数

    对象可以作为参数传递，传递参数时，传递的并不是变量本身而是变量中存储的值
  
  * 函数作为参数
  
  * 函数返回值
  
    任何值都可以作为返回值使用（包括对象和函数之类）
  
    如果return后不跟任何值，则相当于返回undefined；如果不写return，那么函数的返回值也是undefiend
  
    return之后的代码不会继续执行，遇到return函数执行结束
  
  * 箭头函数
  
    * 返回值 (a, b) => a + b
    
    * 箭头函数的返回值可以直接写在箭头后
    
      如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来
  
* 方法——为对象设置的一个函数

* window对象

  * 在浏览器中，浏览器提供了一个window对象，可以直接访问

  * window对象代表的时浏览器窗口，通过该对象可以对浏览器窗口进行各种操作

    除此之外window对象还负责存储JS中的内置对象和浏览器宿主对象

  * window对象的属性可以通过window对象访问，也可以直接访问

  * 函数就可以认为时window对象的方法

* var 用来声明变量，作用和let相同，但是var不具有块作用域

  * 在全局中使用var声明变量，都会作为window对象的属性保存
  * 使用function声明的函数，都会作为window的方法保存
  * 使用let声明的变量不会存储在window对象中，而是存在一个秘密的小地方（无法访问）
  * var虽然没有块作用域，但有函数作用域

#### 作用域

* 指一个变量的可见区域

* 全局作用域

  * 全局作用域在网页运行时创建，在网页关闭时销毁
  * 所有直接编写到script标签中的代码都位于全局作用域中
  * 全局作用域中的变量是全局变量，可以在任意位置访问
  * 关闭网页后全局变量被销毁

* 局部作用域又叫块作用域

  * 块作用域是一种局部作用域
  * 块作用域在代码块执行时创建，代码块执行完毕时销毁

* 函数作用域

  * 函数作用域也是一种局部作用域
  * 函数作用域在函数调用时产生，调用结束后销毁

* 作用域链

  当使用一个变量时，JS解释器会优先在当前作用域中寻找变量，如果找到了则直接使用，如果没找到则继续去上一层中寻找，依此类推；如果一直到全局作用域都没找到，则报错 xxx is not defined
  
* 变量的提升

  使用var声明的变量，它会在所有代码执行前声明，可以在变量声明前访问变量

* 函数的提升

  使用**函数声明**创建函数，会在代码执行前被创建，相当于赋值，可以在函数声明前调用函数；变量和函数的提升同样适用与函数作用域
  
* 立即执行函数(IIFE)

  * 匿名函数且只调用一次
  * 可以利用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题

  在开发中应该尽量减少直接在全局作用域中编写代码，代码尽量编写到局部作用域中

  如果使用let声明变量，可以使用{}来创建块作用域

* 函数中的this

  * 函数在执行时，JS解析器每次都会传递一个隐含的参数，即this
  * this会指向一个对象，且会根据函数的调用方式的不同而不同
    * **以函数形式调用，this指向的是window**
    * 以方法形式调用，this指向的是调用方法的对象
  * 通过this可以在方法中引用调用方法的对象

* 箭头函数中的this

  * **箭头函数没有自己的this，它的this由外层作用域决定**
  * 箭头函数的this和它的调用方式无关

* JS运行代码的模式有两种：

  * 正常模式
    * 默认情况下都运行在正常模式中
    * 在正常模式，语法检查并不严格，原则是能不报错的地方尽量不报错
    * 这种处理方式导致代码的运行性能较差
  * 严格模式
    * 在严格模式下，语法检查变得严格
      1. 禁止一些语法
      2. 更容易报错
      3. 提升了性能
    * 包括全局严格模式和函数严格模式
  * 在开发中应尽量使用严格模式，可以发现一些隐藏的问题，同时能够提升代码的运行性能

#### 面向对象

* 面向对象编程(oop)

* 使用Object创建对象的问题

  * 无法区分出不同类型的对象
  * 不方便批量创建对象

* 在JS中可以通过类（class）来解决以上问题

  * 类是对象的模板，可以将对象中的属性和方法直接定义在类中，定义后就可以直接通过类来创建对象
  * 通过一个类创建的对象被称为同类对象
    * 可以通过instanceof来检查一个对象是否是由某个类创建
    * 如果某个对象是由某个类所创建，则称该对象是这个类的实例
    * 为类创建属性：实例属性和类属性（静态属性）
    * 为类创建方法：实例方法和静态方法（类方法）
  * 构造函数
    * 在类中添加的一个特殊的方法——构造函数/构造方法
    * 构造函数会在调用类创建对象时执行
    * 可以在构造函数中为实例属性进行赋值
    * 在构造函数中this表示当前所创建的对象

* 三大特点

  * 封装——为代码提供了安全性

    * 对象就是用来存储不同属性的容器
    * 对象不仅存储属性还要负责数据的安全
    * 直接添加到对象中的属性并不安全，因为可以被任意更改
    * 如何确保数据的安全：
      * 私有化数据——将需要保护的数据设置为私有，只能在类内部使用
      * 提供setter和getter方法来开放对数据的操作
        * 可以控制属性的读写权限
        * 可以在方法中对属性的值进行验证
    * 封装主要用来保证数据的安全
    * 如何实现封装：
      1. 属性私有化 加#
      2. 通过getter和setter方法来操作属性

  * 继承——为代码提供了扩展性

    * 通过extends关键字完成继承

    * 当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中

    * 被继承的叫做父类（超类），继承的类叫做子类
  
    * 通过继承可以减少重复的代码，并且可以在不修改一个类的前提下对其进行扩展
  
    * 通过继承可以在不修改一个类的情况下对其进行扩展
  
    * OCP开闭原则
  
      程序应该对修改关闭，对扩展开放
  
  * 多态——为代码提供了灵活性
  
    * 在JS中不会检查参数的类型，任何数据都可以作为参数传递
    * 要调用某个函数，无需指定的类型，只要对象满足某些条件即可
    * 多态使代码编写更加灵活
  
* 对象的结构

  * 对象的存储区域

    * 对象自身
      * 直接通过对象所添加的属性，位于对象自身中
      * 在类中通过x = y 的形式添加的属性，位于对象自身中
    * **原型对象**(prototype)
      * 对象中有些内容会存储在原型对象中
      * 在对象中会有一个属性用来存储原型对象，这个属性是\__proto__
      * 原型对象也负责为对象存储属性
        * 当访问对象中的属性时，首先访问对象自身的属性
        * 对象自身不包含该属性时，才会去原型对象中寻找
      * 会添加到原型对象中的情况：
        1. 在类中通过xxx(){}方式添加的方法位于原型中
        2. 主动向原型中添加的属性或者方法 

  * **原型**

    * 访问一个对象的原型对象

      对象.\__proto__

      Object.getPrototypeOf(对象)——Object的静态方法

    * 原型对象中的数据

      1. 对象中的数据（属性、方法）
      2. constructor（对象中的构造函数）

    * 注意

      * 原型对象也有原型，构成一条原型链，根据对象的复杂程度不同，原型链的长度不同

        * P对象的原型链：P对象-->原型-->原型-->null

        * obj的原型链：obj对象-->原型-->null

      * 原型链：

        * 读取对象属性时，会优先对象自身属性

          如果对象中有，则使用，没有则去对象的原型中去寻找；

          如果原型中有，则使用，没有则去原型的原型中去寻找；

          直到找到Object对象的原型（Object的原型没有原型为null）；

          如果依然没有找到，则返回undefined

        * 作用域链是找变量的链，找不到会报错

        * 原型链是找属性的链，找不到会返回undefined

    * 原型的作用

      * 原型相当于一个公共的区域，可以被所有该类的实例访问，可以将该类实例中，所有的公共属性（方法）统一存储到原型中，只需要创建一个属性，即可被所有实例访问
      * JS继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的实例

    * 修改原型

      * 大部分情况下不需要修改原型对象

        注意：不要通过类的实例去修改原型

      * 除了\__proto__能访问对象的原型外，还可以通过类的prototype属性来访问实例的原型

        修改原型时，最好通过类去修改实例的原型

        优点：修改所有实例的原型；无需创建实例即可完成对类实例原型的修改

    * instanceof  用来检查一个对象是否是一个类的实例

      * instanceof 检查的是对象的原型链上是否有该实例，只要原型链上有该类实例就会返回true
      * Object是所有对象的原型，所以任何对象和Object进行instanceof 运算都会返回true

    * in：使用in运算符检查属性时，无论属性在自身还是在原型中，都会返回true

      对象.hasOwnProperty(属性名) （不推荐使用）——用来检查一个对象的自身是否含有某个属性

      Object.hasOwn(对象, 属性名)——用来检查一个对象的自身是否含有某个属性

  * new运算符

    * 当使用new去调用一个函数时，这个函数将会作为构造函数调用

      1. 创建一个普通的JS对象（Object对象{}）

      2. 将构造函数prototype属性设置为新对象的原型

      3. 使用实参来执行构造函数，并且为新对象设置为函数中的this

      4. 如果构造函数返回的是一个非原始值，则该值会作为new运算的返回值返回

         如果构造函数的返回值是一个原始值或者没有指定返回值，则新对象将会作为返回值返回

         **通常不会为构造函数指定返回值**

* 对象总结

  * 对象的分类
    * 内建对象：由ES标准所定义的对象
    * 宿主对象：由浏览器提供的对象，BOM、DOM
    * 自定义对象：由开发人员自己定义的对象

#### 数组

* 遍历数组——枚举：for...of...遍历**可迭代对象**

* 数组的方法

  * 非破坏性

    * at()——
    
    * concat()—— 
    
    * indexOf()——获取元素在数组中的第一次出现的索引
    
      参数：要查询的元素+查询的起始位置
    
    * lastIndexOf()——获取元素在数组中最后一次出现的位置
    
      返回值：找到了则返回元素的索引；没找到则返回-1
    
    * join()——将一个数组中的元素连接成一个字符串
    
      参数：指定一个字符作为连接符
    
    * slice()——用来截取数组
    
      参数：截取的起始位置（包括）；截取的结束位置（不包括）
    
      如果两个参数都省略，则可以对数组进行**浅拷贝**
    
    * filter()——将数组中符合条件的元素保存到一个新数组中返回
    
      * 需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将原数组添加到新数组中
      * 非破坏性方法，不影响原数组
    
    * map()——根据当前数组生成一个新数组
    
      * 需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素
    
    * reduce()——可以用来将一个数组中的所有元素整合为一个值                       
    
    * 浅拷贝和深拷贝
    
      * 浅拷贝
    
        * 通常对象的拷贝都是浅拷贝
        * 浅拷贝只对对象的浅层进行复制（只复制一层）
        * 如果对象中存储的数据是原始值不需要考虑拷贝的深浅
        * 浅拷贝只会对对象本身进行复制，不会复制对象中的属性（或元素）
    
        ![image-20230319215811759](C:\Users\ccwangxin\AppData\Roaming\Typora\typora-user-images\image-20230319215811759.png)
    
      * 深拷贝
    
        * 深拷贝指不止复制对象本身还复制对象中的属性和元素
        * 因为性能问题，通常情况不太使用深拷贝——structuredClone(arr)
    
        ![image-20230319215901634](C:\Users\ccwangxin\AppData\Roaming\Typora\typora-user-images\image-20230319215901634.png)
    
  * 破坏性的方法
  
    * push()——向数组的末尾添加一个或者多个元素，并返回新的长度
  
    * pop()——删除并返回数组的最后一个元素
  
    * unshift()——向数组的开头添加一个或者多个元素，并返回新数组的长度
  
    * shift()——删除并返回数组的第一个元素
  
    * splice()——可以删除、插入、替换数组中的元素
  
      参数：删除的起始位置、删除的数量、要插入的元素
  
      返回值：返回被删除的元素
  
    * reverse()——反转数组
    
    * sort()——数组排序
    
      * sort用来对数组进行排序（会改变原数组）
      * sort默认将数组升序排序，默认会按照Unicode编码进行排序，所以如果直接通过sort对数字进行排序可能会得到错误的结果
      * 可以传递一个回调函数作为参数，通过回调函数来指定排序规则
    
    * forEach()——遍历数组
    
      * 需要传递一个回调函数作为参数，该回调函数会被调用多次
      * 数组中有几个元素，回调函数就会被调用几次，每次调用都会将数组中的数据作为参数传递
      * 回调函数有三个参数：
        * element——当前元素
        * index——当前元素的索引
        * array——被遍历的数组
  
* 数组排序

  * 冒泡排序
  * 选择排序

* 高阶函数

  * 如果一个函数的参数或者返回值是函数，则这个函数称为高阶函数

    * 为什么要将函数作为参数传递？（回调函数有什么作用？）

      将函数作为参数，可以对另一个函数动态的传递代码

  * OCP原则方便函数扩展

  * 回调函数：将函数作为参数传递给其它函数

* 闭包

  * 闭包简介

    * 能访问到外部函数作用域中变量的函数
    * 构成闭包的要件：
      * 函数嵌套
      * 内部函数引用外部函数变量
      * 内部函数作为返回值返回

  * 闭包的原理

    * 函数的作用域，在函数创建时就已经确定（词法作用域）和调用位置无关 

  * 闭包的生命周期

    * 闭包在外部函数调用时产生，外部函数每次调用时都会产生一个全新的闭包
    * 在内部函数丢失时销毁（内部函数被垃圾回收了，闭包才会消失）

  * 注意事项

    * 闭包主要用来隐藏一些不希望被外部访问的内容，需要占用一定的内存空间

    * 相较于类来说，闭包比较浪费空间（类可以使用原型儿闭包不能）

      需要执行次数多时，使用闭包

      需要大量创建实例时，使用类
  
* 递归

* arguments

  * arguments是函数中又一个隐含参数，是一个类数组对象（伪数组）
  * 和数组相似，可以通过索引来读取元素，也可以通过for循环变量，但是它不是一个数组对象，不能调用数组的方法
  * arguments用来存储函数的实参，无论用户是否定义形参，实参都会存储到arguments对象中
  * 可以通过该对象直接访问实参
  
* 可变参数

  - 在定义函数时可以将参数指定为可变参数，
  - 可变参数可以接受任意数量实参，并将他们统一存储到一个数组中返回
  - 可变参数的作用和arguments基本一致，不同点：
    * 可变参数的名字可以自己指定
    * 可变参数就是一个数组，可以直接使用数组的方法
    * 可变参数可以配合其他参数一起使用

#### 垃圾回收

* 如果一个对象没有任何的变量对其引用，那么这个对象就是一个垃圾

* 垃圾对象的存在会严重影响程序的性能
* 在JS中有自动的垃圾回收机制，这些垃圾对象会被解释器自动回收，无需手动处理
* 将不在使用的变量设置为null

#### 声明变量

* var:具有hoisting性质,可先声明后赋值
* let:可先声明后赋值
* const:在声明时赋值,定义了对值的常量引用

#### Undefined 与 Null 的区别

`Undefined` 与 `null` 的值相等，但类型不相等：

```
typeof undefined              // undefined
typeof null                   // object
null === undefined            // false
null == undefined             // true
```

#### 数组

* 尽量用[]而不用新建数组对象的方式

* list.push(value)——向数组的最后添加元素，返回数组长度

  list.pop()——弹出最后一位元素，返回被弹出的元素

  list.shift()——删除数组的首个元素并返回删除的值

  list.unshift(value)——向数组的首位添加元素，返回数组的个数

  `splice()` 方法可用于向数组添加新项，并返回已删除项的数组

  Math.max.apply(null, arr4)——查找数组中的最大值

  Math.min.apply(null, arr4)——查找数组中的最小值
  
* **Array.forEach()** 

  方法为每个数组元素调用一次函数（回调函数）。

* **Array.map()**

  `Array.map()` 方法通过对每个数组元素执行函数来创建新数组。

  `Array.map()` 方法不会对没有值的数组元素执行函数。

  `Array.map()` 方法不会更改原始数组。

* **Array.filter()**

  `filter()` 方法创建一个包含通过测试的数组元素的新数组

* **Array.reduce()**

  `reduce()` 方法在每个数组元素上运行函数，以生成（减少它）单个值。

  `reduce()` 方法在数组中从左到右工作。另请参阅 reduceRight()。

  `reduce()` 方法不会减少原始数组。

