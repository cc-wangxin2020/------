## JS高级程序设计

#### 6. 集合引用类型

* `Array`
  * 可使用`...`扩展操作符进行迭代，`...`能够实现对可迭代对象的浅复制
  * 通过`new Array()`或者`Array()`创建新的数组对象
  * 通过`.length`属性查看对象中元素的个数
  * `from()`方法将类数组结构转化为数组实例，`of()`将一组参数转化为数组实例
  * `Array.isArray()`判断一个对象是否是数组
  * `copywith()`批量复制数组，`fill()`数组填充方法，`toString()`将数组以字符串形式返回，`join()`以某种形式连接数组元素
  * `pop()`方法从数组尾部弹出元素，`push()`方法从数组尾部添加元素
  * `shift()`方法从数组头部添加元素，`unshift()`从数组头部删除元素
  * 排序方法：`reverse()`和`sort()`
  * `slice()`数组切片，`splice()`数组删除、插入、替换
  * 查找元素：`indexOf()`、`lastINdexOf()`、`includes()`
  * 迭代方法：`every()`、`some()`、`filter()`、`forEach()`、`map()`
  * 归并方法：`reduce()`迭代所有数组元素并返回一个值
* 定型数组
  * 包含一套不同的引用类型，用于管理数值在内存中的类型
* 原始包装类型
  * `Boolean`
  * `Number`
  * `String`
* 内置对象
  * `Global`
  * `Math`
* ES6新增引用类型
  
  * `Map`
  
    * 可使用`...`扩展操作符进行迭代，`...`能够实现对可迭代对象的浅复制
  
    * 通过`new Map()`创建新对象，通过`.size`属性查看对象中键值对的个数
    * `set()`方法添加键值对，`has()`和`get()`方法查询对象中的键，`delete()`和`clear()`方法删除值
    * `keys()`、`values()`和`entries()`用来遍历对象中键值对
    * 可使用`...`扩展操作符进行迭代
  * `Set`
  
    * 可使用`...`扩展操作符进行迭代，`...`能够实现对可迭代对象的浅复制
  
    * 通过`new Set()`创建新对象，通过`.size`属性查看对象中键值对的个数
    * `add()`方法添加键值对，`has()`和`get()`方法查询对象中的键，`delete()`和`clear()`方法 删除值
    * `keys()`、`values()`和`entries()`用来遍历对象中键值对
    * 可使用`...`扩展操作符进行迭代
  * `WeakMap`——弱映射，描述的是`JavaSript`垃圾回收程序对待“弱映射”中键的方式，不可迭代对象
    * 键只能是`Object`类型或继承自`Object`的类型
    * `set()`方法添加键值对，`has()`和`get()`方法查询对象中的键，`delete()`方法删除键值对；无`clear()`方法
    * 弱键——这些键不属于正式的引用，不会阻止垃圾回收
    * 使用弱映射，以对象实例为键，私有成员为值，能够实现真正的私有变量
  * `WeakSet`——弱集合，描述的是`JavaScript`垃圾回收程序对待“弱集合”中值的方式
  
    * 值只能是`Object`类型或继承自`Object`的类型
    * `add()`方法添加键值对，`has()`和`get()`方法查询对象中的键，`delete()`方法删除键值对；无`clear()`方法
    * 弱值——这些值不属于正式的引用，不会阻止垃圾回收
    * 使用`WeakSet`可以为`DOM`对象打标签，当`DOM`元素被删除后，垃圾回收程序将释放其内存

#### 7. 迭代器和生成器

* 可迭代协议
  * 暴露一个属性作为“默认迭代器”，该属性以`Symbol.iterator`作为键，以一个迭代器工厂函数为值，调用这个工厂函数能够返回一个新迭代器
* 迭代器协议
  * 使用`next()`方法遍历可迭代对象的数据，每次调用`next()`将返回一个`IteratorResult`对象
  * `IteratorResult`对象包含两个属性`done`和1`value`；`done`为`false`表示还有数据

#### 8. 对象、类与面向对象编程

* 创建对象

  * 工厂模式

    通过一个简单的函数创建对象，为其添加属性和方法后返回该对象

    ```python
    function createPerson(name, age, job){
        let o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function(){
            console.log(this.name);
        }
        return o;
    }
    ```

    

  * 构造函数模式

    ```python
    function createPerson(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
            console.log(this.name);
        }
    }
    ```

    * 没有显示地创建对象
    * 属性和方法直接赋值给了this
    * 没有返回return
    * 缺点：成员无法共享，属性和方法

  * 原型模式

    将属性和方法添加到构造函数的prototype属性上来共享属性和方法

* 继承

  * 原型链

    所有继承的属性和方法都会在对象实例间共享，无法做到实例私有

  * 盗用构造函数

    在子类构造函数中调用父类构造函数，让每个实例继承的属性都是私有的，但只能通过构造函数模式定义

  * 组合继承

    通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性

  * 原型式继承

    无需定义构造函数而实现继承，本质上是对给定对象的浅复制

  * 寄生式继承

    创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象

  * 寄生式组合继承

    

* 类

  * 类构造函数

    * 实例化——使用new操作符对类进行实例化，也就是对constructor函数进行实例化
      * 在内存中创建一个新对象
      * 这个新对象内部的[[prototype]]指针被赋值为构造函数的prototype属性
      * 构造函数内部的this被赋值为这个新对象（即this指向新对象）
      * 执行构造函数内部的代码（给新对象添加属性）
      * 如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象。
  
  * 继承
  
    `super`：`super()`等同于`super.constructor()`

#### 9. 代理和反射

